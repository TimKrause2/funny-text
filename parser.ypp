%require "3.6"

%union {
    int INT;
    char *str;
    q_string *q_str;
    q_string_list_element *q_element;
}

%token <INT> INT
%token <str> STRING
%type <q_str> q_string q_string_content q_string_element
%type <q_element> q_string_list q_string_list_element
%define parse.error verbose
%define parse.lac full
%define api.pure full
%locations
%param { yyscan_t scanner }

%code requires {
    typedef void* yyscan_t;
}

%code top {
    #include "qstring.h"
    #include <stdio.h>
}

%code {
    int yylex ( YYSTYPE * lvalp, YYLTYPE * llocp, yyscan_t scanner);
    void yyerror(YYLTYPE* yyllocp, yyscan_t unused, const char* msg);
    int parse_file(const char *filename, yyscan_t scanner);
}

%%

input:
    %empty
    | input statement
    ;
    
statement:
    q_string
    {
        splice<q_string>(&g_root_string,$1);
    }
    | STRING ':' q_string_list ';'
    {
        q_string_list *list = new q_string_list($1,$3);
        splice<q_string_list>(&g_substitution_list,list);
    }
    | '|' STRING '|'
    {
        if(parse_file( $2, scanner )==0){
            YYERROR;
        }
        free($2);
    }
    ;

q_string:
    '<' q_string_content '>' { $$ = $2;};

q_string_content:
    q_string_element { $$ = $1; }
    | q_string_content q_string_element
    {
        splice<q_string>(&$1,$2);
        $$ = $1;
    }
    ;
    
q_string_element:
    STRING             { $$ = new q_string_copy( $1 ); }
    | '|' STRING '|'   { $$ = new q_string_ref( $2 ); }
    ;

q_string_list:
    q_string_list_element { $$ = $1; }
    | q_string_list q_string_list_element
    {
        splice<q_string_list_element>(&$1,$2);
        $$ = $1;
    }
    ;
    
q_string_list_element:
    INT q_string {$$ = new q_string_list_element($1,$2);}
    ;
%%

